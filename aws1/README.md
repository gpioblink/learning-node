# DAY3 (DAY2と並行)

「AWSによるサーバーレスアーキテクチャ」を読破する。
作ったサンプルコードやテストコードはここにあげる。

## 本の構成

1. サーバレスの基本原則・主なアーキテクチャとパターン
2. 認証・認可、AWS Lambda、Amazon API Gateway
3. 実用的なその他サービス・アーキテクチャ(Amazon S3, Firebase)

## Chapter 1

- サーバレスの特徴は、開発者がサーバーやインフラを気にかけずにコードに全力を注げるようにすること。

- SOA(サービス指向アーキテクチャ)とはシステムは多くの独立したサービスにより組み立てられるということを明確に概念化したアーキテクチャ。マイクロサービスとサーバレスアーキテクチャはこのSOAの精神を受け継いでいる。特定のテクノロジーを強要するものではなく、メッセージのやりとりにより通信し、メッセージの作成・交換の方法を定義したスキーマやコントラクトを持つサービスを作るべきとするアーキテクチャ上のアプローチ。

- マイクロサービスとは、特定のビジネス目的や機能を中心として構築された小さくスタンドアローンで完全に独立したサービス。さまざまな汎用言語やドメイン固有言語で賭けるため言語や仕事にあったライブラリを選べる利点があるが、まともな計画がないとトランザクション管理や複雑なエラー修復のため話が難しくなる。

- サーバレスアーキテクチャでは、マイクロサービスの原則をたくさん取り入れても、少しだけ取り入れても構わないようにできている。

- ソフトウェア設計は、現在は階層設計が好まれる。階層化すると個々の問題が切り離され、メンテナンスしやすいアプリケーションを作れる。ただし、多くなりすぎると複雑になる。サーバレスアーキテクチャはそれを解決する。

- ティアはシステムの大きなコンポーネントを分離するためのモジュール境界。同じティアにまとめられるコンポーネントでも、物理的に別インフラに配置されることがある。例えば、ユーザーから見えるプレゼンテーションティアは、ビジネスロジックを含むアプリケーションから分離されている。データティアはデータを管理・永続化し、データのアクセスを提供するシステム。

- レイヤーは、アプリケーションの特定の機能を実行する論理的な断片。個々のティアは複数の階層を持ち、それらの階層はドメインサービスなどの別々の機能の処理を任される。

- ティア(層)の中に複数のレイヤー(階層)がある。

- サーバレスのアプローチは、階層化の問題や、更新が多くなりすぎる問題や土台の解決をしてくれるわけではないが、正しく実装することで複雑さを軽減し、整理し、管理するチャンスが得られる。

- 従来はプレゼンテーションティア（フロントエンド）、アプリケーションティア・データティア（バックエンド）であった。サーバレスアーキテクチャでは従来型のシステムのようなバックエンドは存在せず、プレゼンテーションティアが直接サービスやデータベース、APIGateWayを通したコンピュート関数にアクセスする。

- サーバレスアーキテクチャの原則５「オンデマンドでコードを実行するために、（サーバーではなく）コンピューティングサービスを使う」「目的が１つでストレートな関数を書く」「プッシュベースのイベント駆動パイプラインを設計する」「より厚くより強力なフロントエンドを作る」「サードパーティサービスを活用する」

- オンデマンドでコードを実行するために、コンピューティングサービスを使う。SOAの考え方を自然な形で拡張したもの。単独で独立して実行されるので、すべてのカスタムコードがAWS Lambdaのようなステートレスなコンピューティングサービスで実行できる。カスタムコードの多くは粒度の細かい関数として記述されるので、データソースの読み書き、他関数の呼び出し、関数の実行など、一般的なタスクの大半を実行するために関数を開発者は楽に書くことができる。複雑なタスクも、複雑なパイプラインをつくり複数の関数呼び出しをオーケストレートして扱える。

- 目的が１つでストレートな関数を書く。単一責任原則(Single Responsibility Principle)を念頭に置いて関数を設計すべき。たった１つだけのことをする堅牢で副作用の少ない関数をかく。これを守ることによって、複雑なバックエンドシステムでも管理しやすく理解しやすい状態になる。AWS Lambdaなどコンピューティングサービスを対象とするコードは、今あるセッションを超えたリソースやプロセスの生き残っていることを前提とせず、ステートレスなスタイルで書くべき。ステートレスなコードを書くことは、入力イベント、リクエストのかずに応じてすばやくスケーリングできるなど強力である。

- プッシュベースのイベント駆動パイプラインを設計する。プッシュベースのイベント駆動システムは、変更をポーリングするためのコードが不要なため、コストが下がり複雑さが軽減される。また、ユーザーエクスペリエンス自体がスムースになる場合もある。ただし、プッシュベースのイベント駆動モデルは、実現が不可能な場合があり、イベントソースをポーリングする場合、スケジュールに従って実行されるLambda関数が必要な場合もある。

- AWS LambdaとはNode.js,Python,C#,Javaのいずれかで書かれたコードを実行するコンピューティングサービス。ソースコードはzipにまとめられ、コンテナにデプロイされる。コード、設定、依存ファイルの組み合わせ全体をLambda関数と呼ぶ。AWS Lambdaはプッシュ、プルの両イベントモデルをサポートして多くのAWSサービスと統合されている。類似サービスとしてMicrosoft Azure Functions, IBM Bluemix, OpenWhisk, Google Cloud Functionsといったコンピューティングサービスもある。

- サーバレスアーキテクチャの設計スタイルの例(プッシュベースパイプライン):「S3(新しい動画のアップロード),S3バケットに動画をアップロードすると、AWSでイベントがトリガリングされLambda関数が起動する」「Lambda関数(トランスコードジョブの作成),ソースファイルから新しい動画ファイルを作るElasticTranscoderジョブを返す」「AmazonElasticTranscoder(動画のトランスコード),トランスコードサービスがジョブを実行し、新しい動画をエンコードする」「S3(新しい動画の保存),エンコード済みの動画が、AmazonElasticTranscoderによって新しいS3バケットに保存され別のイベントがトリガリングされる」「Lambda関数(メタデータの更新),イベントに対して別のLambda関数が反応し、データベースに書き込まれた動画のメタデータを作成する」「データベース(メタデータのデータベースへの保存)」「Lambda関数(通知の作成),データベース変更をきっかけに自動的にメール通知を作成するLambda関数が呼び出される)」「通知サービス(通知のディスパッチ)」

- より厚くより強力なフロントエンドを作る。AWS Lambdaで実行されるカスタムコードは、サービス料金がリクエスト数・実行時間・割り当てられたメモリーのサイズによって決まるためすばやく実行できるないといけない。そのため、複雑なバックエンドではなく、サードパーティサービスと直接やりとり可能な豊かなフロントエンドを作ればよい。これは、ユーザーエクスペリエンスの向上にもつながる。オンラインリソース間のポップ数が減りレイテンシが下がると、アプリケーションのパフォーマンスやユーザビリティが改善される。例えば、フロントエンドは、検索プロバイダ・データベース・その他役に立つAPIと直接通信することもできる。電子署名されたトークンを使えば、フロントエンドはデータベースなど様々なサービスとセキュアにやりとりすることができる。ただし、機密情報の処理にはフロントは信用できないので、データチェック・セキュリティやアクションの調整のためにコンピューティングサービスを使うべきである。また、フロントの処理が途中で失敗すると、整合性が取れていない状態になるので、失敗したオペレーションを再度実行できるようにするLambda関数が使うべきである。

- サードパーティサービスを活用する。自分に与えられた時間は、誰かがすでに実装した機能を改めて作るのではなく、自分の領域に固有な問題を解決することに使うべき。新たに自作することを自己目的化するべきではない。「巨人の肩の上に立つ」べき。もちろん、サードパーティサービスを検討するときは、価格、性能、可用性、ドキュメント、サポートなどの要素を評価しようね！

- サーバーからサーバーレスに乗り換えるときは、モノシックなコードを少しずつ切り出し、アプリケーションとやりとりできるLambda関数を作っていけばよい。移行作業の際は、古いコードに依存する制約などでうまく動かないことがあるので、システムの一部や全部をサーバレスにしたときどのように機能するかについてテストするプロトタイプを作るとよい。サーバレス化が厳しいときは、スケーリングが難しくなるなどありおすすめはできないが、モノシックとサーバレスのハイブリッドシステムを作ることもできる。また、移行作業には時間がかかるので、事前にテストプランとDevOps戦略を用意するべきである。

- なんでもかんでもサーバレスにするのは厳しい。例えば、具体的なSLA(Service Level Agreement)のもとでレイテンシーに厳しい規則があったりすると対応しにくい。以下に採用の判断基準をあげる

- サーバーレス採用の判断基準としては次の５つの観点がある。「万能でないサーバレス」「サービスレベル」「カスタマイズ」「ベンダーロックイン」「脱中央集権化」。

- 万能でないサーバレス。パブリッククラウドで実行されるので、銀行のオンラインシステムや生命維持装置などミッションクリティカル(重要,重大)なアプリケーションを作るべきではない。どうしてもサーバレスにしたいなら、プライベートクラウドを独自に用意し、サービス提供能力や信頼性の要件を満たすと良い。

- サービスレベル。AWSにはSLAがあるサービスとないサービスがあるので、これが判断材料の１つになる。大規模な案件になるとSLAのニーズに答えられないことがある。

- カスタマイズ。AWS LambdaはAmazonにプラットフォームとスケーリングを任せるので効率が上がるが、OSのカスタマイズやその下のインスタンスの調整は犠牲になる。AWSの場合は、RAMの容量やタイムアウトくらいしか変更できない。

- ベンダーロックイン。そのサービスを使うことでアーキテクチャはそのプラットフォームに密結合する危険性が高まる。

- 脱中央集権化。リモート呼び出しやエラー処理にサーバレス独特な処理が必要になることもある。サーバレスは分散的な性質を持つので、サーバレス固有の問題が起きることがある。

- サーバレスには次のような５つの利点がある「サーバー不要」「多くの用途」「低コスト」「コード量の削減」「スケーラブルで柔軟」

- サーバー不要：サーバーの構成や管理、パッチ、メンテナンスはベンダーが行ってくれる。自分は自社のコードだけに責任を負えばいい。多くの用途：ステートレスでスケーラビリティが高いため、並列処理が効果的である問題の解決に使える。低コスト：スケーリングの単位が細かく、無駄なコストがかかりにくい。コード量の削減：高い層のバックエンドシステムを用意できる。コード量の削減：従来型のシステムと比べてコードの複雑さを軽減するチャンスが生まれる。スケーラブルで柔軟：サーバレスシステムは従来型のシステムより簡単にスケーリングできる。

## Chapter 2

- サーバレスとはAWS Lambdaなどのコンピューティングサービスでコードを実行することだけではない。しなければならない仕事を減らすためにサードパーティ製のサービスやAPIを利用することも含まれる。

- AWSには次のようなIoTプラットフォームがある「認証と認可（権限付与）」「デバイスゲートウェイ」「レジストリ（個々のデバイスに一位なIDを割り当てるための手段）」「デバイス（永続的なデバイスの状態情報）のシャドウ」「ルールエンジン（デバイスのメッセージを変換し、AWSにサービスにルーティングするサービス）」

- ルールエンジンはAmazon S3にファイルを保存し、Amazon Simple Queue Service (Amazon SQS)キューにデータをプッシュし、Lambda関数を起動できる。AmazonのIoTプラットフォームはサーバーを実行することなくデバイスのスケーラブルなIoTバックエンドを簡単に構築できる。

- サーバレステクノロジーは、データ処理、変換、操作、トランスコードに幅広く使われていて、AWS LambdaとAWSサービスは、データ処理タスクのためのイベント駆動パイプラインを作るのに非常に適している。パイプラインとは例えば、ファイルへのアクセス権限を設定し、メタデータファイルを作るなど。

- リアルタイム分析は、ストリームに新しいレコーをが追加されるとすばやく反応し、データを処理・保存・破棄できるようにする。この仕組みは、データの分析・集計・格納するデータを大量に生成するアプリケーションに適している。Amazon Kinesis Data Streamsなどを使うとログ・システムイベント・トランザクション・ユーザークリックなどのデータを取得できる。この場合Lambda関数がバッチの処理に失敗すると、成功するまで最大２４時間バッチの思考が続けられる。

- Amazon API GatewayとAWS Lambdaを使うと、レガシーなAPIの上に新しいAPIの階層を作り、古いAPIを使いやすくしてくれる。Amazon API Gatewayは、RESTfulなインターフェイス作成のため、Lambda関数はリクエストとレスポンスを入れ変え、古いサービスが理解する形式に変換するために使われる。

- スケジューリングされたサービスも、Lambda関数で実行できる。データーのバックアップや、リマインダーアラートに適している。AWSにはこの目的のためのBlueprint(設計図)が用意されているため、簡単にこなすことができる。

- サーバレスシステムは一般に「バックエンド（ウェブおよびモバイルアプリケーションのバックエンド）」と「グルー（ワークフローを実行するために組み立てられるパイプライン）」の２つを相互補完的に組み合わせて開発する。アーキテクチャとパターンの大半は、この２つを専門特化させ多様化したもの。

- サーバレスのシステムがデータベースや認証サービスと直接リンクしているのは、フロントエンドとこういったものが委任トークン(delegation token)などでセキュアに通信できるから。

- サーバレスバックエンドを構築するときは、イベント駆動パイプラインと違って、「分厚いフロントエンド」と「サードパーティサービスの活用」が鍵となる。優れたサーバレスシステムはLambda関数が使われる範囲と量を極力減らすために努力する。そのため、データ変換の数を最小限に抑えることが重要である。

- Lambda関数の粒度を細かくしすぎるとバックエンドがふくれあがってしまうが、粒度を気にしないとモノシックになってしまう。例えば、動画サイトのトランスコート処理では、複雑さをコントロールできる範囲に収めるためにlambda関数内のデータ変換の数を最小限に抑えるようにするとよい。

- 多くの場合、クライアントはAmazon API Gatewayを介したリレーを行わず直接サービスと通信できる。

- Amazon API Gatewayは、リクエストを変換して他のHTTPエンドポイントに対してリクエストを発行することができるが、JSON変換だけで済むユースケースしか使えない。複雑なときは、データの変換・リクエストの発行、レスポンス処理のためにLambda関数が必要になる。例えば、SOAP(Simple Object Access Protocol)サービスに接続してレスポンスをJSONに変換するっために、Lambda関数を書く必要がある。

- ハイブリッドシステムは、既存インフラの一部がすでにAWSにあるときは、うまく機能する。例えば、開発者たちが補助的なデータ処理やバックアップなど、スタンドアローンのコンポーネントを作っていて、時間とともにシステム全体をサーバレステクノロジーにしている事例もある。

- 事例「EXP Labs」Amazon DynamoDB内に作成されたジョブは、スケジューラに送られて、次に判断するタスクをディスパッチする。ディスパッチはタスクのタイプにより、AmazonSNSを介してAWS Lambdaにタスクをpingするか、SQS(Simple Queue Service)にメッセージをプッシュするか選択される。

- GraphQLは、Facebookが開発し2012年に開発し、2015年にリリースされた人気が高いデータクエリ言語。REST(Reprentational State Transfer)に替わるものとして設計された。単一のエンドポイント(たとえば、api/graphql)で宣言的な階層構造でクエリを実行することで、複数のラウンドトリップ・オーバーフェッチ・バージョニングが可能。

- AWS AppSyncはiOSやReact Native、Webなどのクライアントアプリケーションに対し、データの検索やリアルタイム同期、オフライン実行や通知の提供する。AWS AppSyncがResolverデータソース、AWS Lambda関数、Amazon Elasticsarch serviceを選択する。AppSyncはモバイルアプリ開発を助ける強力なSDKである。

- GraphQLは、クライアントに権限を与える。レスポンスはサーバーで決めるのではなく、クライアントで定義できる。GraphQLは一度のラウンドトリップで、複数のソースからデータを１つにまとめてクライアントに返すため効率よくデータを取り出せる。実際に、Facebookでは、GraphQLはほぼ1000種類のバージョンのアプリケーションから毎秒数百万個ものリクエストを処理している。

- GraphQLは、Amazon DynamoDBなどの複数のデータソースに読み書きでき、リクエストに合わせてレスポンスを組み立てる。AmazonDynamoDBなど複数のデータを読み書きでき、リクエストに合わせてレスポンスを組み立てる。

- Compute-as-glueアーキテクチャはLambda関数を使って強力な実行パイプラインとワークフローを作ろうとする考え方。サービスとサービスの間のグルー（糊）としてサーバー間の調整やサーバーの起動のためにLambda関数を使う。

- ListHub（外部データソース、AmazonS3のRESTファイルストレージや、外部メディアストレージ）の処理エンジン作る例。ListHubはプッシュ機能を一切もっていないため、LambdaでS3オブジェクトの最終変更日時のっメタデータをチェックし、更新を確認する。

- 事例「EPX Labs」巨大ファイルのパースには時間がかかるので(AWS Lambdaの実行時間上限は５分)、Amazon ECSを使っている。ECSコンテナでは、入力ファイルを非同期に処理し結果をAmazon S3に書き込む。プログラムにはClojureを使用している。

- Amazon Kinesis Data Streamsは、膨大なストリーミングデータの処
理や分析を助けるテクノロジ。使うとできる３つのこと、「データストリームに渡されるデータの量を決めたり、最初にデータを送り込むか制御することができる。」「Kinesisデータストリームを、Amazon API Gatewayの背後に配置すること。」「クライアントから直接ストリームにデータをプッシュしたり、Lambda関数にレコードを追加させたりすること。」

- パターンとは、ソフトウェア設計の問題に対するアーキテクチャ上の解決策で、ソフトウェア開発で広く見られる問題に対処するために設計されている。パターンはサーバレスだけのものではなく、分散システムで以前から使われてきたもの。ここで登場するパターン以外にも、認証・データ管理・エラー処理に関連したパターンはよく理解しておくこと。

- Commandパターンは、要求された処理を実際に実行するエンティティから操作の呼び出しもとを切り離す。このパターンは、呼び出し元とレシーバーを切り離したいときに役立つ。例:Amazon API GateWay -> Lambda関数(コマンド,この1つの関数が他の関数を呼び出すために使われる。データやイベントに基づきこの関数はどの関数を呼び出すべきか知っている。) -> 様々なLambda関数

- Messagingパターンとは、関数やサービスを直接的な相互依存関係から切り離し、イベント、レコード、リクエストにキューを格納するパターン。コンシューマーサービスがオフラインになっても、メッセージはキューに残り、あとで処理できる状態を保つため、高い信頼性が得られる。関数間の密結合も減らせる。このパターンは、データ、メッセージ、リクエストを大量に処理するときに使うべき。例:複数のデータソース->キュー、ストリーム(Amazon SQS Simple Queue Service, Amazon Kinesis Data Streams)->Lambda関数(ディスパッチ, Commandパターンンと同様に、キューからメッセージに基づいて適切なLambda関数を呼び出す)->複数のLambda関数

- メッセージキューのセンダー・レシーバは１つでも多数でもよい。SQSキューはキューごとに１つのレシーバーを持つ。複数のコンシューマーを持ちたい場合は、Amazon SQSとAmazon SNSを組み合わせてシステムに複数のキューを導入すればよい。トピックにメッセージをプッシュすると、サブスクライブしているすべてのキューに自動的にメッセージがプッシュされる。

- ↑正常に処理できないメッセージを他のキューに使用できるデッドレターキューなどの機能はないが、Amazon SQS + SNSの代わりにAmazon Kinesis Data Streamsを使うこともできる。Amazon Kinesis Data Streamsは、AWS Lambdaと統合されているため、マルチコンシューマーをサポートしている。

- Priority queueパターンは、処理の優先度別に別々のワークフローで処理するパターン。すぐに処理しないといけないものはコストのかかるサービスや能力の高いAPIを使い、急ぐ必要がないものはまた別のワーウフローを使う。このパターンでは、全く異なるSNSトピック、Kinesisデータストリーム、SQSキュー、Lambda関数をつくることになるので、複雑度が増してしまうので控えめに使うべき。有料ユーザーと無料ユーザーに対して異なるサービスやAPIを使うワークフローを定義したりできる。

- Fanoutパターンは、特定のキューやメッセージパイプラインをリスン・サブスクライブするのに使われるパターン。AWSでは複数のサブスクライバーを呼び出せる。トピックに新しいメッセージが追加されると、強制的に全てのサブスクライバーが同時に起動されるので、イベントを「ファンアウト(扇形に送出することができる)」。これは、並列に処理を実行できるイベント駆動形アーキテクチャをつくる効率的な方法である。同時に複数のLambda関数を呼び出さないといけないときに役立つ。

- Pipes and filtersパターンは、複雑なタスクを分解して、パイプラインに並んだ一覧の管理しやすい別々のサービスに整理する目的。「フィルタ」とは、データの変換を目的とするコンポーネントのこと。「パイプ」とは、コンポーネントからコンポーネントにデータを受け渡すコネクターのこと。サーバレスアーキテクチャはこのパターンと相性がいい。

- Lambda関数はどれも粒度の細かいサービス、単一責任原則を念頭に置いて書く。つまり、入力と出力を明確に定義し、副作用を最小限に抑える。

- Pipes and filtersパターンを使うときは、次の４つのルールに従って、一連のパイプラインに分解することを検討する。「単一責任原則に従った関数を書くようにすること」「関数を冪等(同じ入力に対してはいつも同じ出力が生成される)にすること」「関数のインターフェイスを明確に定義すること。入力と出力を明確に指定する」「ブラックボックスをつくること。関数のコンシューマーは、関数がどのような仕組みになっているかを知らなくても使い方がわかり、どのような出力が得られるかわかっていないといけない」

## AWSのインストール・セットアップの大まかな手順

1. npm, AWS CLIをインストール
1. IAMユーザ・ロール、動画を格納するためのS3パケット、動画をトランスコードするためのErastic Transcoderパイプラインを作成
  
  - IAM(Identity and Access Management)の設定はこんな感じ
    ```
    AWS Access Key ID [None]: AKI***************
    AWS Secret Access Key [None]: **************************
    Default region name [None]: us-east-1
    Default output format [None]: json
    ```

  - 作成したIAMにはユーザーアクセス権限を設定し、Lambda関数をデプロイできるようにする。GetFunctions,UpdateFunctionCode,UpdateFunctionConfigurationを許可すれば良い。 

  - S3バケットは、アップロード用のserverless-video-uploadとトランスコート保管用のserverless-video-transcodedの２つを作る。（バケット名はAmazon のグローバルで一意でないといけない。）

  - 将来のLambda関数のためにIAMロールを作る。Lambdaサービスを選択して、AWSLambdaExecute(Lambda関数にAmazonS3,AWS CloudWatchとのやりとりを認める)とAmazonElasticTranscoder_JobsSubmitter(Lambda関数がAmazonElasticTranscoderに新しいトランスコードジョブを実行できるようにする)の2つのポリシーをあタッチする。

  - 最初のLambda関数を作成する。関数名はtranscode-videoで、ロールは先程作成したlambda-s3-execution-roleとする。

  - Amazon Elastic Transcoderを使って、動画を他の形式、ビットレートにトランスコードできるよう、ElasticTranscoderのパイプラインを作る。