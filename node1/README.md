# DAY1 (なんでも開発合宿一日目)

「Javascript本格入門」を読破する。
作ったサンプルコードやテストコードはここにあげる。

## Chapter 1

- 「ブラウザー以外の環境でもJavaScriptを利用したいという方は、特にChapter 5までの内容を確実に理解するようにしてください」

- Chromeのdevツールでブレイクポイントから１行単位にブレイクポイント指定もできる

## Chapter 2

- コメントで無効にすることを「コメントアウト」というが、再び有効にすることは「コメントイン」という。

- varとletの違いは２点で、「変数の重複を許可しない(上書きしない)」と「ブロックスコープを認識する」こと。

- ただの数値(1.08など)は、自分以外にとっては意味を持たないマジックナンバーと考えるべき。ES2015ではconstが使える。

- 数値リテラルでは、10進のほかに16(0x),ES2015では8(0o),2(0b)進が使える

- 文字リテラルは基本型(文字リテラルがそのままメモリ上に格納される)

- ダブルクォートとシングルクォートのちがいはなし

- es2015にはテンプレート文字列がある

- オブジェクトと連想配列は同一のもの。オブジェクト内の個々のデータはプロパティと呼び、関数を格納されたプロパティのことを特別にメソッドという。ただしES2015では連想配列を専門に扱うMapが追加された

- オブジェクトのキー指定には、ドット演算子もブラケット構文も使えるが、ブラケット構文のほうが識別子の命名規則によらないので汎用性が高い

- Javascriptは関数もリテラルの１つとして扱われる。

- 意図した空を表すにはnull、そうでなければundefined

- 小数の掛け算は不正確なので、掛けようとするかずをまず10の累乗倍して、最終的な結果を小数点以下で四捨五入した後、かけた数を乗算しふただび小数点にもどすといい。このかける数は有効数字で決めること。

- constであっても参照型の場合は配列そのものを再代入するのでなければconstの規約違反にはならない。

- ES2015では分割代入ができる。これを`[x,y] = [y,x];`のように使えばswapも一行でできるね！

``` JavaScript
let data = [1,2,3,4,5];
let [x0, x1, x2, ...other] = data;
//順番に変数名をつけて取り出し
console.log(x0); // 1
console.log(other); //[4,5]
```

``` JavaScript
//名前で個々の変数を分解。入れ子もそのとおりに掛けばおｋ。「変数名:別名」の形式でもかける。宣言のない代入のときは({ごにょごにょ} = book);でいける
let book = { title: 'Java聖書リファレス', publish: '並木先生', price: 2680 };
let { price, title, memo = 'なし'} = book;
```

- 「==」の等価演算子では、「オペランドのデータ型が違う場合にもデータ型を変換してなんとか等しいとみなせないか」を試みる。例えば、「1 == true」は「true」とみなされる。ただし、参照型の場合はアドレスが一致するかしか見ないので注意。

- 「==」の場合は例えば「0x10」という文字リテラルと「16」という数値リテラルをtrueとしてしまう。これはこの「x」が16進数の意味でない場合も同様。そこで、型まで一致するか見る「===」同値演算子を使えば良い。

- 「?:」もちろん条件演算子`console.log((x >= 70) ? '合格' : '不合格');`もある。

- ショートカット演算子の使い時として、`msg = msg || 'デフォルト値';`とするとmsgがfalsyな空文字などのときにデフォルト値にできたりする。

- 2進数で負数を表すとき、「ビット列を反転させて１加えたものが、その絶対値になる」という規則がある。

- delete演算子の特徴３つ「配列の要素を削除しても、後ろの要素は繰り上がらない（インデックス番号は変わらない）」「プロパティを削除した場合でも、プロパティそのものが削除されるだけで、プロパティが参照するオブジェクト自体は消えない」「`var data2 = 1`などの明示的に宣言された変数は削除できない」

- typeof演算子は基本データ型の識別はできるが、配列やオブジェクト、また基本型のラッパーオブジェクトは一様に「object」と返される。objectの種類を知りたいときはinstanceof演算子やconstructorプロパティを使う

- カンマ演算子を使うと`for(var i=1, j=1; i<5; i++,j++)`のように書ける。

- for...in命令もある。ただし、配列で使用するとコードがシンプルにならず、処理の順序がおかしくなったり、仮変数にはインデックス番号が格納されるだけだったりするので注意。

- 配列用にES2015では「for...of命令」が追加された。これは列挙可能オブジェクトを順番通りに処理し、仮変数もインデックス番号やキーではなく値そのものを列挙する

- 配列のサイズは、「.length」で取得できる

- document.writeよりもtextContentやinnerHTMLを使うこと。document.writeは特殊な動きをもち「ドキュメント全て出力したあとに呼び出すとページが一旦クリアされる」などの挙動をする。

- breakには次のようにしてラベルをつけられる

``` JavaScript
kuku:
for(){
    for(){
        if() break kuku;
    }
}
```

- 例外処理はtry...catch...finally。オーバーヘッドが大きい処理なのでループ処理の中で使用するのは控え、ループ処理の外に配置するなど工夫をする。エラーをthrowするときは`throw new Error('エラー原因の解説')`とする。Errorの代わりにEvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIErrorなどもthrowできる。

- strictモードにするにはスクリプトの先頭や関数本体の先頭に`'use strict';`と書けばいい。

- async/defer属性を使うことで、外部スクリプトを非同期にロードできる。`<script src="app.js" async></script>`とすることで、src属性で指定されたスクリプトを非同期にロードし、読み込み完了次第実行するようになる。この場合読み込み順が保証されあいので、その場合defer属性をつけるとスクリプトの実行を文書の解析完了まで延滞できる。

### 識別子の使い方

- 変数・関数名　camelCase記法

- 定数名 アンダースコア記法

- クラス名 Pascal記法

## Chapter 3

- オブジェクトはそれ自身がデータを保持しようとするものなので、特殊な例外を除いて基本的に複数の箇所から異なる値をセットしようとしてはいけない

- 組み込みオブジェクトとは、「JavaScriptに標準で組み込まれた」という意味で、ブラウザーに限らず組み込みオブジェクトはJSが動作するすべての環境で利用できる。

- Object, Array, String, Boolean, Number, Symbol, Functionなどは、組み込みオブジェクトの中でもデータ型と対応していて、リテラルをそのまま対応する組み込みオブジェクトとして利用できるので、インスタンス化をほとんど意識する必要がない。他にも組み込みオブジェクトには、Map/WeakMap, Set/WeakSet, Math, Date, RegExp, Error/XxxxxError, Proxy, Promiseがある。

- 基本データ型をnew演算子を使ってインスタンス化するのは原則避ける。さもないと以下のようになる

``` JavaScript
var flag = new Boolean(false);
if (flag) {
    console.log('flagはtrueです！！');
} // ここで「null以外のオブジェクトはtrueとみなされる」ため、if内が実行されてしまう。
```

- JSのデータ型を扱うオブジェクトの中でも基本形の文字、数値、理論値を扱うためのオブジェクトをラッパーオブジェクトという。ラッパーオブジェクトは「単なる値に過ぎない基本形のデータを包んで、オブジェクトとしての機能を追加するためのオブジェクト」である。JSはこれを自動的に相互変換するため開発者は意識する必要はない。

- `str.indexOf(部分文字列substr, 検索開始インデックスstart);`を使うことで文字列前方(start+1文字目)から部分文字列substrを検索できる。不一致の場合は`-1`が返る

- 「叱」などのサロゲートペア文字の長さをカウントするとき、Unicodeで2バイトではなく4バイトで表現しているため、「.length」ではこれを２文字と認識してしまう。回避は以下のようにする

```JavaScript
var mag = '叱る';
var len = msg.length;
var num = msg.split(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g).length -1;
console.log(msg.length - num);
```

- Numberオブジェクトは、整数整形の機能の他に無限大・無減小/整数型の最大値・最小値など特別な値を表すための定数を公開している。Numberで安全に表せる最大の整数値はES2015でMAX_SAFE_INTEGER。EPSILONなんかもある。

- 演算の結果がJSで表現可能な値を超えるとPOSITIVE_INFINITYなどになり、０除算などの不正な場合はNaNとなる。NaNは自分自身を含む全ての値と等しくない

- `!!`のように「!」演算子を２重に使うことで理論型への変換ができる

- ES2015ではSymbolオブジェクトが追加され、「モノの名前」を作成することができる。列挙定数を表すようなケースで使う。定数の値は同名であってもユニークになる。(例：MONDAY=0の場合でもMONDAYと等しいのはMONDAYのみ)。プライベートプロパティ、イテレータの定義にシンボルを使うこともできる。性質は、newできない、引数が同じでも別物として扱われる、===での比較では異なるものとみなされる、「-0」や「+ ''」を使った暗黙的な型変換は不可（booleanの「!!」は可）。

- Mathオブジェクトは全て静的プロパティ・メソッド

- 同じオブジェクトを繰り返し呼び出す場合、with命令でオブジェクト名を省略できる。ただし処理速度低下や可読性低下の原因になるのでサンプルコード以外では使わないこと。

```JavaScript
with(console){
    log(Math.abs(-100));
    log(Math.sign(-100)); //正・負・０いずれかの符号
    log(Math.ceil(1234.56));
}
```

- Arrayもnewで作ろうとすると意味が曖昧になるため、できる限り配列リテラルを使う。

- reverseやsortなどのメソッドは戻り値だけでなく、もとの配列もソートされてしまうので注意。（破壊的なメソッド）

- コールバック系のメソッドでは、大本のメソッドが基本となる操作を提供しする。そのためその範囲の中でどのような加工・演算を行うかは、ユーザー定義関数が決める、という役割分担が基本。

- オブジェクトリテラルとMapオブジェクトの違いは３つ。任意の型でキーを設定できる。マップのサイズを取得できる（オブジェクトのときはfor...inなどで手動カウントしないといけない）。クリーンな(完全に空の)マップを作成できる（オブジェクトは作成時点でObjectオブジェクトしてのプロパティが最初から存在する）。

- Mapオブジェクトのキーに関する注意点として、「`1`」と「`'1'`」のように型が違うと同じとみなされない、`NaN === NaN`とみなされる、オブジェクトの比較は参照アドレスでの比較となるので注意しないといけない。

- SetオブジェクトでもMapと同様に、NaNは同一とみなされ、違う起源の{}と{}は別物として追加される。

- キーを弱参照で管理するWeakSetとWeakMapもある。弱参照では、キーがこのマップ以外で参照されなくなると、ガベージコレクトの対称となる。そのためWeakMap/WeakSetでは、キーは参照型でなければならず、列挙することができない。

- Dateオブジェクトには日付や時刻を直接加算・減算するためのメソッドは用意されていないため、getXxxxxメソッドで個々の日付、時刻要素を取り出し、加算・減算した結果をsetXxxxxメソッドで書き戻すという手順が必要になる。

```JavaScript
var d = new Date();
var d = new Date('2016/12/24 20:45:23');
var d = new Date(2016,11,2,44,55,22,300); //月だけは0~11での指定となるので注意。時刻の部分は省略できる。
var d = new Date(1480849635543); //タイムスタンプ値での指定
```

- 経過ミリ秒を日付にするには　経過ミリ秒÷(1000ミリ秒*60秒*60分*24時間) をすればよい

- 郵便番号のRegular Expressionは「`[0-9]{3}-[0-9]{4}`」というパターンで表せる。

- 正規表現について詳しく知りたいなら、「詳説 正規表現 第３版」を読め

- RegExpオブジェクトを作成する方法。RegExpオブジェクトのコンストラクタを経由する、正規表現リテラルを利用する方法がある。

```JavaScript
var hoge = new RegExp('正規表現', 'オプション'); //この構文では正規表現の「\」をJSの予約文字と認識されないようにエスケープすること
var hoge = /正規表現/オプション;
```

- 検索時に、String.matchを使う場合とRegExp.execを使う場合では挙動が違う。execではgオプションにかかわらず１つの実行結果しか返さない。これは、execコマンドが「最後にマッチした文字位置を記憶しているからであり、RegExpオブジェクトは「前回のマッチ位置から検索を再開する」

```JavaScript
var p = /http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%&=]*)?/gi;
var str = 'サポートサイトはhttp://www.wings.msn.to/です。'
str += 'サンプル紹介サイトHTTP://www.web-deli.com/もよろしく！'
while((result = p.exec(str)) !== null){
    console.log(result[0]);
}
```

- マッチした文字列自体ではなく、マッチングの成否のみを知りたい場合には「`regexp.test(str)` true/false」または「`str.search(pattern)` 最初にマッチした文字位置 or -1」を使える！

- replace/splitの第一引数にはRegExpオブジェクトだけではなく、ただの文字列リテラルを指定することもできる。その場合、正規表現ではなく、固有文字列で置き換え・分割される。

- Javascriptのオブジェクトは基本的に、「オブジェクトの共通的な性質・機能を提供する」という役割を担っている。Objectオブジェクトはすべてのオブジェクトの基本オブジェクトであるともいえる。つまり、組み込みオブジェクトも、ユーザー定義オブジェクトもObjectオブジェクトで定義されたプロパティやメソッドを共通して利用することができる。

- オブジェクトと名前がつくものはすべて、Objectオブジェクトで定義されたプロパティやメソッドを共通して利用することができる。

- 例外的にObjectクラスの機能を引き継がないものもあるが、Object.createというメソッドを利用することでObjectの機能を引き継がないオブジェクトを作成することもできる。

- オブジェクトはtoString（文字列を返す）/valueOf(文字列以外の基本型の値が返されることを「期待して」使われる)メソッドを使用することで基本形に変形できる。オブジェクトを自作するならまともなtoStringを定義しよう。valueOfは組み込みオブジェクトは自分自身を返すだけ。例外として、Dateオブジェクトだけが日付・日時のタイムスタンプ値を返す。オブジェクトが基本型として表せるなら個々に定義すること。

- オブジェクトをマージするassignメソッドは、既存のオブジェクトを結合できる。`Object.assign(target, source, ...)`破壊的なメソッドであることに注意。元のオブジェクトに変更を及ぼしたくない場合は`let merged = Object.assign({}, pet, pet2, pet3)`のようにすればよい。

- オブジェクトを生成するcreateメソッドは、名前をもたない匿名オブジェクトを生成する最もシンプルな手段。`Object.create(作成するオブジェクトのもととなるオブジェクトproto [,プロパティ情報props])`。protoにObject.prototypeを渡しているのは、「Objectオブジェクトの機能を引き継いだオブジェクトを作成しない」という意味。

- 完全にからのオブジェクトを作成したい場合は`Object.create(null)`とすればよい。

- Object.createで利用できる属性は主にconfigurable(writable以外の属性変更やプロパティ削除が可能か)、enumerable(列挙を可能とするか)、value、writable(書き換え可能か)、getter/setter関数などがある。またconfigurable/enumerable/writableのデフォルト値はいずれもfalseである。

- 不変オブジェクトとは、最初にインスタンスを作成した後、一切の状態を変更できないオブジェクトのことをいう。

- JavaScriptプログラムでよく利用する機能を提供するGlobalオブジェクトがある。これはnewでインスタンス化したり、`Global.メソッド名(...);`メンバーを呼び出せるわけではない。グローバルオブジェクトであり、つまり`Global.`なしで`変数名`、`関数名(引数,...)`として参照できる。

- `Number.isNaN('hoge')`はfalseだが、グローバルオブジェクトの`isNaN('hoge')`はtrueとなる。これはNumberオブジェクトでは「引数が数値型であり、かつ、NaNである」ものだけをtrueとしているためである。isFiniteも同様の挙動。

- クエリ文字列のためにURIエンコードする、`encodeURI(str)`と`encodeURIComponent(str)`の違いは、componentのほうが`#$+/@;:,`などの変換もするところにある。

- eval関数は与えられた文字列をJSのコードとして評価・実行する。しかし、セキュリティリスクやパフォーマンス劣化の原因になるため乱用は避けるべき。eval is evil

- JSONで利用できるリテラル表現と、JavaScriptのリテラル表現は３点「プロパティ名はダブルクォートでくくらなければならない」「配列・オブジェクト配下の要素はカンマで終わってはいけない」「ゼロ始まりの数値は禁止」という制約がある。

### 不変オブジェクトの種類

- preventExtensionsは、プロパティの追加のみ不可にし、削除や値の変更は可能とする
- sealは、プロパティの追加と削除のみ不可能にし、値の変更は可能とする
- freezeは、プロパティの追加、削除、値の変更のいずれも不可能にする

これらの規則を破ったとき、無視されるだけでstrictモードでないと例外を発生しないため、これらの機能を使うときはstrictモードを有効にすべきである。

### 値の集合を管理・操作するオブジェクトについて

- Arrayオブジェクト インデックス管理 値の重複可
- Mapオブジェクト キー/値の組で管理 キーの重複不可
- Setオブジェクト 値に順番はない 値の重複はNG

### 文字列の数値変換について

- parseFloat/parseIntメソッド
  - 「123xxx」のような文字列混在の数字を「123」のように解析できる部分だけを数値として取り込む。ただし先頭から連続した場合のみ(「xxx123」などは不可)
  - Dateオブジェクトの解析は不可
  - 「0x10」は、parseFloatでは上の条件より「x」の前の「0」となり、parseIntでは16進数とみなして「16」を返す。ただし、ES2015で追加された２、８進数の解析はできない。
  - 「1.01e+2」は、parseFloatは正しく認識、parseIntは「e+2」の前の「1.01」を切り捨て1となる

- Number関数
  - 「123xxx」のような文字列混在の数字はNaNになる
  - Dateオブジェクトは「Dateオブジェクトを経過ミリ秒に換算した値」として返す
  - 「0x10」は、16進数とみなして「16」を返す
  - 「1.01e+2」は、正しく認識

### 部分文字列抽出について

- substring
  - 開始位置〜終了位置で抽出箇所を指定
  - start>endのときstartとendの関係を入れ替えて抽出
  - startやendに負の数を指定すると無条件に0

- slice
  - 開始位置〜終了位置で抽出箇所を指定
  - start>endのとき入替はせず空文字も返す
  - startやendに負の数を指定すると「文字列末尾からの文字数」と認識

- substring
  - 開始位置からの文字数指定で抽出箇所を指定